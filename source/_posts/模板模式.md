---
title: 模板模式
abbrlink: 202009131022
date: 2020-09-13 16:23:05
tags: [模板模式]
Categories: [设计模式]
cover: https://cdn.jsdelivr.net/gh/zhangbiao-code/blog_cdn@master/image/essay/202009131022/cover.png
description: Mybatis的相关知识学习总结以及对整体的体系架构和工作流程的梳理，通过学习总结该部分内容深入理解该框架。
---

### 模板模式的定义

> 模板模式通常又叫模板方法模式(Template Method Pattern)是指在父类中定义一个流程的骨架，允许子类为一个或者多个流程内的具体步骤提供实现。模板方法使得子类可以在不改变流程顺序的情况下，重新定义流程中的某些步骤具体的实现，属于行为性设计模式。

**个人理解：**
    模板模式是在继承的基础上衍生出来的概念，注重业务执行的`顺序`，在相同的需求不同的业务中，将代码执行流程的步骤定义在父类中，多种业务场景下相同的行为放在父类中，单个步骤的业务不一致则将具体实现定义在子类中，以这样的形式来减少代码的冗余，和增加代码的拓展性，这样的形式即可认为是模板模式(这样更好理解，但描述的有些片面和过激)个人认为在相同的需求不同的业务的情况下`步骤的顺序`是模板模式的核心。

### 模板方法适用于以下应用场景:

+ 一次性实现一个流程的不变的部分，并将可变的行为留给子类来实现
+ 各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复

举例：
1. 办理入职流程填写入职登记表-->打印简历-->复印学历-->复印身份证-->签订 劳动合同-->建立花名册-->办理工牌
2. 平时在家里炒菜:洗锅 -->点火-->热锅-->上油-->下原料-->翻炒-->放调料-->出锅

### 模板模式的优缺点

优点:

+ 利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性
+ 将不同的代码放在不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性
+ 把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台， 符合开闭原则

缺点:

+ 类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加
+ 类数量的增加，间接地增加了系统实现的复杂度
+ 继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍

### 实际项目中Excel数据导入案例

该部分业务场景为:

    有多个Excel模板，客户希望在不同的业务模块下下载该模块固定的Excel模板，将数据录入模板后并将模板上传，系统自动将模板内的数据录入到系统中。

使用模板模式原因：录入数据的过程是一样的,只是每个模板解析数据的行列、数据校验和存储时所需的操作对象不同,所以可以使用模板模式,在模板中定义执行流程,不同的解析数据的方式可以放到不同子对象中实现,录入数据的过程可以分为:

    1. check模板文件是否正确 
    2. 加载该文件遍历解析出每一行数据 
    3. 将数据解析到集合中 
    4. 批量存储数据 
    5. 清除该过程中使用的临时对象或集合

创建一个模板类 AbstractLoadExcelDataTemplate:

```java
/**
 * excel模板数据导入模板
 */
public abstract class AbstractLoadExcelDataTemplate {

    ...

    public String excelName; // excel模板名称

    public String dataSheetName; // sheet页名称

    public int dataBeginLineNum; // excel 数据起始行数

    public final static String suffix = "xlsx";

    ...

    // 模板模式核心控制流程的代码
    public void inputData(MultipartFile file) throws BusinessException, IOException {

        XSSFSheet sheet = this.checkFile(file);

        Row row;

        for (int rowNum = this.dataBeginLineNum; rowNum <= sheet.getLastRowNum(); rowNum++) {

            row = sheet.getRow(rowNum);

            try {
                this.readData(row);
            } catch (BusinessException e) {
                throw new BusinessException("第【" + rowNum + "】行中" + e.message);
            }
        }

        this.saveData();

        this.clear(); // 释放资源
    }

    abstract void readData(Row row) throws BusinessException;

    abstract void saveData();

    abstract void clear();

    public XSSFSheet checkFile(MultipartFile file) throws BusinessException, IOException {

        XSSFSheet sheet = null;

        if (file != null) {

            String originalFilename = file.getOriginalFilename();
            String[] arr = originalFilename.split("\\.");

            checkSuffix(arr[1]);
            checkExcelName(arr[0]);

            InputStream is = file.getInputStream();
            XSSFWorkbook workbook = new XSSFWorkbook(is);

            sheet = checkDataSheetName(workbook);
            checkSheetDataIsNotNull(sheet);
        }

        return sheet;
    }

    private void checkExcelName(String excelName) throws BusinessException {

        if (!this.excelName.equals(excelName)) {
            throw new BusinessException("不可修改模板文件名称，请先恢复模板名称再尽心数据导入");
        }
    }

    private void checkSuffix(String suffix) throws BusinessException {

        if (!this.suffix.equals(suffix)) {
            throw new BusinessException("模板文件格式错误");
        }
    }

    private XSSFSheet checkDataSheetName(XSSFWorkbook workbook) throws BusinessException {

        XSSFSheet sheet = workbook.getSheet(this.dataSheetName);
        if (sheet == null) {
            throw new BusinessException("无可录入数据的sheet页(不可修改sheet页名称)");
        }
        return sheet;
    }

    private void checkSheetDataIsNotNull(XSSFSheet sheet) throws BusinessException {
        if (!(sheet.getLastRowNum() > this.dataBeginLineNum)) {
            throw new BusinessException("请先将数据录入模板文件再进行导入");
        }
    }

    /**
     * check时间格式为YYYY-MM-DD
     * @param time
     * @return
     */
    public boolean checkDate(String time) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");
        try {
            Date t = dateFormat.parse(time);
        } catch (Exception ex) {
            return false;
        }
        return true;
    }

    /**
     * check金额后面只允许有两位小数
     * @param money
     * @return
     */
    public boolean checkMoney(String money) {

        if (money.contains("\\.")) {
            if (money.split("\\.")[1].length() > 2) {
                return false;
            }
        }
        return true;
    }
}
```

该业务中存在两处模板数据录入：1、项目的数据导入  2、项目里程碑的数据导入(里程碑：项目的阶段介绍如项目开始阶段，验收阶段，维护阶段等)

创建项目对象LoadProjectBaseData
```java
public class LoadProjectBaseData extends AbstractLoadExcelDataTemplate {

    public String excelName = "项目基本信息导入模板";

    public String dataSheetName = "项目导入模板";

    public int dataBeginLineNum = 3;

    ...

    public LoadProjectBaseData() {
        super.excelName = this.excelName;
        super.dataSheetName = this.dataSheetName;
        super.dataBeginLineNum = this.dataBeginLineNum;
    }

    @Override
    public void readData(Row row) throws BusinessException {

        String projectCode = row.getCell(5).getStringCellValue();

        if (StringUtil.isNullOrEmpty(projectCode)) {
            throw new BusinessException("项目编码不能为空，请先完善数据");
        }

        List<Project> list = projectService.list(new QueryWrapper<Project>().eq("code", projectCode).eq("deleted", 0));

        // 项目编码不存在在当前系统中才进行数据的录入
        if (list.size() <= 0) {

            projectList.add(readCellProjectData(row));

            settleTransferFinalList.add(readCellSettleTransferFinalData(row));

            researchReferenceNumList.add(readCellResearchReferenceNumData(row));

            investPlanInfoList.add(readCellInvestPlanInfoData(row));
        }
    }

    @Override
    public void saveData() {

        projectService.saveBatch(projectList);

        settleTransferFinalService.saveBatch(settleTransferFinalList);

        researchReferenceNumService.saveBatch(researchReferenceNumList);

        investPlanInfoService.saveBatch(investPlanInfoList);
    }

    @Override
    public void clear() {

        this.projectList.clear();
        this.settleTransferFinalList.clear();
        this.investPlanInfoList.clear();
        this.researchReferenceNumList.clear();

        super.deptMap.clear();
        super.projectCategoryMap.clear();
        super.projectYearMap.clear();
        super.projectNatureMap.clear();
        super.projectTypeOneMap.clear();
        super.projectTypeTwoMap.clear();
    }

    private Project readCellProjectData(Row row) throws BusinessException {

        Project project = new Project();

        ...

        project.setProjectTypeOneId(projectTypeOneId);
        project.setProjectTypeTwoId(projectTypeTwoId);
        project.setProjectYear(projectYearId);
        project.setName(projectName);
        project.setCode(row.getCell(5).getStringCellValue());
        project.setRemark(row.getCell(6).getStringCellValue());
        project.setDeptId(deptId);
        project.setDeleted(false);
        project.setCreateTime(LocalDateTime.now());
        project.setCreateUser(currentLoginUserId);

        return project;
    }

    public SettleTransferFinal readCellSettleTransferFinalData(Row row) {

        SettleTransferFinal settleTransferFinal = new SettleTransferFinal();

        ...

        settleTransferFinal.setDeleted(false);
        settleTransferFinal.setCreateTime(LocalDateTime.now());
        settleTransferFinal.setCreateUser(currentLoginUserId);

        return settleTransferFinal;
    }

    private ResearchReferenceNum readCellResearchReferenceNumData(Row row) {

        ResearchReferenceNum researchReferenceNum = new ResearchReferenceNum();

        ...

        researchReferenceNum.setDeleted(false);
        researchReferenceNum.setCreateTime(LocalDateTime.now());
        researchReferenceNum.setCreateUser(currentLoginUserId);

        return researchReferenceNum;
    }

    private InvestPlanInfo readCellInvestPlanInfoData(Row row) {

        InvestPlanInfo info = new InvestPlanInfo();

        ...

        info.setDeleted(false);
        info.setCreateTime(LocalDateTime.now());
        info.setCreateUser(currentLoginUserId);

        return info;
    }

}
```

创建里程碑对象LoadMilepostData

```java
public class LoadMilepostData extends AbstractLoadExcelDataTemplate {

    public String excelName = "项目基本信息导入模板";

    public String dataSheetName = "项目导入模板";

    public int dataBeginLineNum = 3;

    public List<Milepost> milepostList = new ArrayList<>();

    public LoadMilepostData() {
        super.excelName = this.excelName;
        super.dataSheetName = this.dataSheetName;
        super.dataBeginLineNum = this.dataBeginLineNum;
    }

    @Override
    public void readData(Row row) {

        milepostList.add(readCellMilepostData(row));
    }

    @Override
    public void saveData() {

        milepostService.saveBatch(milepostList);
    }

    @Override
    public void clear() {

        this.milepostList.clear();
        super.milepostService = null;
    }

    private Milepost readCellMilepostData(Row row) throws BusinessException {

        Milepost milepost = new Milepost();

        String name = row.getCell(0).getStringCellValue();
        if (StringUtil.isNullOrEmpty(name)) {
            throw new BusinessException("里程碑名称未填写，请先完善数据");
        }

        milepost.setName(name);

        String plannedTime = row.getCell(1).getStringCellValue();
        if (!StringUtil.isNullOrEmpty(plannedTime)) {
            if (!checkDate(plannedTime)) {
                throw new BusinessException("计划时间格式为YYYY-MM-DD,请先调整时间格式");
            }
            milepost.setPlannedTime(LocalDateTime.parse(plannedTime));
        }

        String actualTime = row.getCell(2).getStringCellValue();
        if (!StringUtil.isNullOrEmpty(actualTime)) {
            if (!checkDate(actualTime)) {
                throw new BusinessException("实际时间格式为YYYY-MM-DD,请先调整时间格式");
            }
            milepost.setActualTime(LocalDateTime.parse(actualTime));
        }

        milepost.setReasonsOfDelay(row.getCell(3).getStringCellValue());
        milepost.setPromoteMeasures(row.getCell(4).getStringCellValue());

        milepost.setDeleted(false);
        milepost.setCreateTime(LocalDateTime.now());
        milepost.setCreateUser(currentLoginUserId);
        milepost.setConId(id);
        milepost.setType(milepostType);

        return milepost;
    }
}

```

由于数据录入频率不会过于频繁，所以只需创建一个Controller即可 :

```java
@PostMapping("/excelInputData")
@ApiOperation(value = "模板数据导入", response = Result.class)
public Result excelInputData(@RequestParam("type") int type, @RequestParam("id") long id, @RequestParam(value = "milepostType", required = false) int milepostType, @RequestParam("file") MultipartFile file) {

    try {
        // 根据传入的Type不同过去不同的模板子对象进行解析
        LoadExcelDataEnum excelDataEnum = LoadExcelDataEnum.loadEnum(type);

        // 根据type获取所需要的模板对象
        AbstractLoadExcelDataTemplate template = excelDataEnum.createTemplate();

        template.currentLoginUserId = getUserId();

        // 加载模板所需基础数据
        excelDataEnum.loadTemplateNeedBaseData(template, deptService, projectTypeService, dictionaryService, userService, userRoleService, projectService, settleTransferFinalService, researchReferenceNumService, investPlanInfoService, milepostService, id, milepostType);

        // 导入Excel数据
        template.inputData(file);

        return ResultGenerator.genSuccessResult();
    } catch (BusinessException e) {
        e.printStackTrace();
        return ResultGenerator.genFailResult(e.message);
    } catch (Exception e) {
        e.printStackTrace();
        return ResultGenerator.genFailResult(ErrorCode.SYS_ERROR);
    }
}
```

上面代码中本应采用工厂模式判断type类型获取不同的模板子对象，但博主可能偏爱枚举对象，认为枚举对象就是工厂和策略的合集，所以上方采用枚举的方式进行获取模板对象。

枚举对象LoadExcelDataEnum

```java
public enum LoadExcelDataEnum {

    PROJECT(1, "项目基本信息导入模板.xlsx") {
        @Override
        public AbstractLoadExcelDataTemplate createTemplate() {
            return new LoadProjectBaseData();
        }

        @Override
        public void loadTemplateNeedBaseData(AbstractLoadExcelDataTemplate template, DeptService deptService, ProjectTypeService projectTypeService, DictionaryService dictionaryService, UserService userService, UserRoleService userRoleService, ProjectService projectService, SettleTransferFinalService settleTransferFinalService, ResearchReferenceNumService researchReferenceNumService, InvestPlanInfoService investPlanInfoService, MilepostService milepostService, long id, int milepostType) {
            // 加载基础数据，以便减少查询次数
            List<Dept> deptList = deptService.list();
            ...

            // 将基础数据放入模板
            template.setDept(deptList);
            ...

            // 注入操作对象
            ...
        }
    },
    MILEPOST(2, "里程碑导入模板.xlsx") {
        @Override
        public AbstractLoadExcelDataTemplate createTemplate() {
            return new LoadMilepostData();
        }

        @Override
        public void loadTemplateNeedBaseData(AbstractLoadExcelDataTemplate template, DeptService deptService, ProjectTypeService projectTypeService, DictionaryService dictionaryService, UserService userService, UserRoleService userRoleService, ProjectService projectService, SettleTransferFinalService settleTransferFinalService, ResearchReferenceNumService researchReferenceNumService, InvestPlanInfoService investPlanInfoService, MilepostService milepostService, long id, int milepostType) {

            template.id = id;
            template.milepostType = milepostType;
            template.milepostService = milepostService;
        }
    };

    public int type;

    public String name;

    LoadExcelDataEnum(int type, String name) {
        this.type = type;
        this.name = name;
    }

    public static LoadExcelDataEnum loadEnum(int type) {

        for (LoadExcelDataEnum excelDataEnum : values()) {
            if (excelDataEnum.type == type) {
                return excelDataEnum;
            }
        }
        return null;
    }

    public AbstractLoadExcelDataTemplate createTemplate() {
        return null;
    }

    public void loadTemplateNeedBaseData(AbstractLoadExcelDataTemplate template, DeptService deptService, ProjectTypeService projectTypeService, DictionaryService dictionaryService, UserService userService, UserRoleService userRoleService, ProjectService projectService, SettleTransferFinalService settleTransferFinalService, ResearchReferenceNumService researchReferenceNumService, InvestPlanInfoService investPlanInfoService, MilepostService milepostService, long id, int milepostType) {
    }
}
```

### 模板模式在源码中的体现

先来看 JDK 中的 AbstractList，来看代码:

```java
package java.util;
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> { 
  	...
		abstract public E get(int index); 
  	...
}
```

我们看到 get()是一个抽象方法，那么它的逻辑就是交给子类来实现，我们大家所熟知的 ArrayList 就是 AbstractList 的子类。同理，有 AbstractList 就有 AbstractSet 和 AbstractMap，有兴趣的可以去看看这些的源码实现。还有一个每天都在用的 HttpServlet，有三个方法 service()和 doGet()、doPost()方法，都是模板方法的抽象实现。

在 MyBatis 框架也有一些经典的应用，比如 BaseExecutor 类，它是一个基础的 SQL 执行类，实现了大部分的 SQL 执行逻辑，然后把几个方法交给子类定制化完成，源码如下:

```java
public abstract class BaseExecutor implements Executor { 
  	...
		protected abstract int doUpdate(MappedStatement var1, Object var2) throws SQLException;
		protected abstract List<BatchResult> doFlushStatements(boolean var1) throws SQLException;
		protected abstract <E> List<E> doQuery(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4, BoundSql var5) throws SQLException;
		protected abstract <E> Cursor<E> doQueryCursor(MappedStatement var1, Object var2, RowBounds var3, BoundSql var4) throws SQLException;
		... 
}
```

如 doUpdate、doFlushStatements、doQuery、doQueryCursor 这几个方法就是交由子类来实现，下面是它的类图:

![image-20200328183440955](http://127.0.0.1/image/blog/image-20200328183440955.png)
